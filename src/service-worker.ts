/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) =>
    url.origin === self.location.origin && url.pathname.endsWith(".webp"),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: "images",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
  if (event.data && event.data.type === "SERVER_MESSAGE") {
    const message = event.data.message;
    // 메시지를 UI에 출력하는 코드
    // 예를 들면, 메시지를 화면의 알림으로 표시하는 등
    return alert(message);
  }
});

const CACHE_NAME = "v3";

self.addEventListener("install", function (e) {
  e.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.addAll([
        // 캐시할 파일 리스트 작성
        "/js/main.15617907.js",
        "/index.html",
      ]);
    })
  );
  self.skipWaiting();
});

self.addEventListener("fetch", function (e) {
  e.respondWith(
    caches.match(e.request).then((response) => {
      return response || fetch(e.request);
    })
  );
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((keyList) =>
      Promise.all(
        keyList.map((key) => {
          if (CACHE_NAME !== key) return caches.delete(key);
          return key;
        })
      )
    )
  );
  self.clients.claim();
});

// Any other custom service worker logic can go here.

self.addEventListener("push", function (event: PushEvent) {
  // 알림 권한 확인
  if (Notification.permission === "default") {
    // 사용자에게 알림 권한 요청
    Notification.requestPermission().then((permission) => {
      if (permission === "granted") {
        console.log("알림 권한이 허용되었습니다.");
        // 알림 표시 코드를 여기에 추가
      } else {
        console.log("알림 권한이 거부되었습니다.");
      }
    });
  } else if (Notification.permission === "granted") {
    console.log("알림 권한이 이미 허용되어 있습니다.");
    // 알림 표시 코드를 여기에 추가
  } else {
    console.log("알림 권한이 거부되어 있습니다.");
  }
  event.waitUntil(
    self.clients.matchAll().then((clientList: readonly Client[]) => {
      const clients = [...clientList];
      const focused = clients.some((client) => {
        if (client instanceof WindowClient) {
          return client.focused;
        } else {
          return false;
        }
      });

      let notificationMessage: string;
      if (focused) {
        notificationMessage =
          "오늘의 감정은 어땠나요? 다른 사람이 공유한 감정도 구경하러가요 !";
      } else if (clientList.length > 0) {
        notificationMessage =
          "하루에 두 개의 감정일기를 쓸 수 있다는 사실을 아시나요? EmoTrak이 기다리고있어요 :)";
      } else {
        notificationMessage = "오늘도 EmoTrak에 일기를 남겨주셔서 감사해요!";
      }

      // Show a notification with title 'ServiceWorker Cookbook' and body depending
      // on the state of the clients of the service worker (three different bodies:
      // 1, the page is focused; 2, the page is still open but unfocused; 3, the page
      // is closed).
      return self.registration.showNotification("EmoTrak", {
        body: notificationMessage,
        lang: "ko",
        icon: "/logo192.png",
        vibrate: [500, 100, 500],
      });
    })
  );
});
